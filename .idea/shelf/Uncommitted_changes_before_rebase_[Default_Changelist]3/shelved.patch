Index: app/src/main/java/com/example/braille2text/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.braille2text\r\n\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport android.os.Bundle\r\nimport org.opencv.android.OpenCVLoader\r\nimport android.widget.Toast\r\nimport android.content.Intent\r\nimport android.view.View\r\nimport android.widget.Button\r\nimport com.chaquo.python.Python\r\nimport com.chaquo.python.android.AndroidPlatform\r\nimport kotlinx.android.synthetic.main.activity_main.*\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n    private var button: Button? = null\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        txtPythonShow.text=getPythonHelloWorld()                      //this prints out the python function helloworld.py\r\n\r\n        if (OpenCVLoader.initDebug()) {\r\n            Toast.makeText(this, \"OpenCV successfully loaded!\", Toast.LENGTH_SHORT).show()\r\n        } else {\r\n            Toast.makeText(this, \"OpenCV cannot be loaded.\", Toast.LENGTH_SHORT).show()\r\n        }\r\n        button = findViewById<View>(R.id.button) as Button\r\n        button!!.setOnClickListener { openCameraActivity() }\r\n    }\r\n\r\n\r\n\r\n    private fun getPythonHelloWorld(): String {\r\n        val python = Python.getInstance()\r\n        val pythonFile = python.getModule(\"test\")\r\n        return pythonFile.callAttr(\"helloworld\").toString()\r\n    }\r\n\r\n    private fun openCameraActivity() {\r\n        val intent = Intent(this, CameraActivity::class.java)\r\n        startActivity(intent)\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/braille2text/MainActivity.kt	(revision 48db88dd91de92680b233372650d3a88afb977cf)
+++ app/src/main/java/com/example/braille2text/MainActivity.kt	(date 1605218023338)
@@ -18,7 +18,8 @@
         super.onCreate(savedInstanceState)
         setContentView(R.layout.activity_main)
 
-        txtPythonShow.text=getPythonHelloWorld()                      //this prints out the python function helloworld.py
+        brailleProcessingLib()
+        txtPythonShow.text = test()
 
         if (OpenCVLoader.initDebug()) {
             Toast.makeText(this, "OpenCV successfully loaded!", Toast.LENGTH_SHORT).show()
@@ -29,12 +30,15 @@
         button!!.setOnClickListener { openCameraActivity() }
     }
 
-
-
-    private fun getPythonHelloWorld(): String {
+    private fun brailleProcessingLib() {
         val python = Python.getInstance()
-        val pythonFile = python.getModule("test")
-        return pythonFile.callAttr("helloworld").toString()
+        val pythonFile = python.getModule("brailleProcessingLib")
+    }
+
+    private fun test(): String{
+        val python = Python.getInstance()
+        val pythonFile = python.getModule("brailleProcessingLib")
+        return pythonFile.callAttr("testing").toString()
     }
 
     private fun openCameraActivity() {
Index: app/src/main/python/brailleProcessingLib.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from imutils.perspective import four_point_transform as FPT\r\nfrom imutils import contours\r\nfrom collections import Counter  # counter\r\nfrom skimage import io  # library to read images\r\nimport matplotlib.pyplot as plt  # library to show image to user\r\nimport numpy as np  # used to process image to arrays\r\nimport imutils  # basic image processing\r\nimport cv2  # advanced for image processing\r\nimport re  # regex\r\n\r\nFILEPATH = 'test.jpg'\r\n\r\n\r\n# test for alphabet translation / iter = 0 (test.jpg)\r\n# test for gaussian blur on nemmeth example / iter >= 3 (test2.jpg)\r\n\r\n# -----------------------FUNCTIONS------------------------- #\r\n\r\ndef get_image(FILEPATH, iter=2, width=None):\r\n    image = io.imread(FILEPATH)  # reads the url and opens the temporary image to user\r\n\r\n    if width:\r\n        image = imutils.resize(image, width)  # resizes the image per the restricted width\r\n    ans = image.copy()  # create a copy backup image\r\n\r\n    # image procesesing\r\n    accumEdged = np.zeros(image.shape[:2], dtype=\"uint8\")\r\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # convert image to black and white\r\n    blurred = cv2.GaussianBlur(gray, (5, 5), 0)  # blur to remove some of the noise\r\n    edged = cv2.Canny(blurred, 75, 200)  # get edges(converts image to easy detectable dots)\r\n    accumEdged = cv2.bitwise_or(accumEdged, edged)\r\n    ctrs = imutils.grab_contours(cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL,\r\n                                                  cv2.CHAIN_APPROX_SIMPLE))  # get contours(increases accuracy)\r\n    docCnt = None\r\n\r\n    # ensure that at least one contour was found to know an image can be processed\r\n    if len(ctrs) > 0:  # sort the contours according to their size in descending order\r\n        ctrs = sorted(ctrs, key=cv2.contourArea, reverse=True)\r\n\r\n        for c in ctrs:  # loop over the sorted contours\r\n            peri = cv2.arcLength(c, True)\r\n            approx = cv2.approxPolyDP(c, 0.02 * peri, True)  # approximate the contour\r\n\r\n            # if our approximated contour has four points, then we can assume we have found the image\r\n            if len(approx) == 4:\r\n                docCnt = approx\r\n                break\r\n    paper = image.copy()  # creates a copy of the processed image\r\n\r\n    # apply Otsu's thresholding method to binarize the image\r\n    thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]\r\n    kernel = np.ones((5, 5), np.uint8)\r\n\r\n    # erode and dilate to remove some of the unnecessary detail\r\n    thresh = cv2.erode(thresh, kernel, iterations=iter)\r\n    thresh = cv2.dilate(thresh, kernel, iterations=iter)\r\n\r\n    # find contours in the thresholded image\r\n    ctrs = imutils.grab_contours(\r\n        cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE))\r\n\r\n    return image, ctrs, paper, gray, edged, thresh\r\n\r\n\r\ndef get_diameter():  # shows the area of interest for the computer\r\n    boundingBoxes = [list(cv2.boundingRect(c)) for c in ctrs]\r\n    c = Counter([i[2] for i in boundingBoxes])\r\n    mode = c.most_common(1)[0][0]\r\n    if mode > 1:\r\n        diam = mode\r\n    else:\r\n        diam = c.most_common(2)[1][0]\r\n    return diam\r\n\r\n\r\ndef get_circles():  # shows the area of interest for the computer\r\n    questionCtrs = []\r\n    for c in ctrs:\r\n        (x, y, w, h) = cv2.boundingRect(c)\r\n        ar = w / float(h)\r\n\r\n        if diam * 0.8 <= w <= diam * 1.2 and 0.8 <= ar <= 1.2:  # region should be sufficiently wide, tall, and have an aspect ratio approximately equal to 1\r\n            questionCtrs.append(c)\r\n    return questionCtrs\r\n\r\n\r\ndef sort_contours(ctrs):\r\n    BB = [list(cv2.boundingRect(c)) for c in ctrs]\r\n    tol = 0.7 * diam  # choose tolerance for x, y coordinates of the bounding boxes to be binned together\r\n\r\n    def sort(i):  # change x and y coordinates of bounding boxes to their corresponding bins\r\n        S = sorted(BB, key=lambda x: x[i])\r\n        s = [b[i] for b in S]\r\n        m = s[0]\r\n\r\n        for b in S:\r\n            if m - tol < b[i] < m or m < b[i] < m + tol:\r\n                b[i] = m\r\n            elif b[i] > m + diam:\r\n                for e in s[s.index(m):]:\r\n                    if e > m + diam:\r\n                        m = e\r\n                        break\r\n        return sorted(set(s))\r\n\r\n    # lists of of x and y coordinates\r\n    xs = sort(0)\r\n    ys = sort(1)\r\n\r\n    (ctrs, BB) = zip(*sorted(zip(ctrs, BB), key=lambda b: b[1][1] * len(image) + b[1][0]))\r\n    # return the list of sorted contours and bounding boxes\r\n    return ctrs, BB, xs, ys\r\n\r\n\r\ndef draw_contours(questionCtrs):\r\n    color = (0, 255, 0)\r\n    i = 0\r\n    for q in range(len(questionCtrs)):\r\n        cv2.drawContours(paper, questionCtrs[q], -1, color, 3)\r\n        cv2.putText(paper, str(i), (boundingBoxes[q][0] + boundingBoxes[q][2] // 2,\r\n                                    boundingBoxes[q][1] + boundingBoxes[q][3] // 2),\r\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)\r\n        i += 1\r\n\r\n\r\ndef get_spacing():\r\n    def spacing(x):\r\n        space = []\r\n        coor = [b[x] for b in boundingBoxes]\r\n        for i in range(len(coor) - 1):\r\n            c = coor[i + 1] - coor[i]\r\n            if c > diam // 2: space.append(c)\r\n        return sorted(list(set(space)))\r\n\r\n    spacingX = spacing(0)\r\n    spacingY = spacing(1)\r\n\r\n    # smallest x-seperation (between two adjacent dots in a letter)\r\n    m = min(spacingX)\r\n\r\n    c = 0\r\n\r\n    d1 = spacingX[0]\r\n    d2 = 0\r\n    d3 = 0\r\n\r\n    for x in spacingX:\r\n        if d2 == 0 and x > d1 * 1.3:\r\n            d2 = x\r\n        if d2 > 0 and x > d2 * 1.3:\r\n            d3 = x\r\n            break\r\n\r\n    linesV = []\r\n    prev = 0  # outside\r\n\r\n    linesV.append(min(xs) - (d2 - diam) / 2)\r\n\r\n    for i in range(1, len(xs)):\r\n        diff = xs[i] - xs[i - 1]\r\n        if i == 1 and d2 * 0.9 < diff:\r\n            linesV.append(min(xs) - d2 - diam / 2)\r\n            prev = 1\r\n        if d1 * 0.8 < diff < d1 * 1.2:\r\n            linesV.append(xs[i - 1] + diam + (d1 - diam) / 2)\r\n            prev = 1\r\n        elif d2 * 0.8 < diff < d2 * 1.1:\r\n            linesV.append(xs[i - 1] + diam + (d2 - diam) / 2)\r\n            prev = 0\r\n        elif d3 * 0.9 < diff < d3 * 1.1:\r\n            if prev == 1:\r\n                linesV.append(xs[i - 1] + diam + (d2 - diam) / 2)\r\n                linesV.append(xs[i - 1] + d2 + diam + (d1 - diam) / 2)\r\n            else:\r\n                linesV.append(xs[i - 1] + diam + (d1 - diam) / 2)\r\n                linesV.append(xs[i - 1] + d1 + diam + (d2 - diam) / 2)\r\n        elif d3 * 1.1 < diff:\r\n            if prev == 1:\r\n                linesV.append(xs[i - 1] + diam + (d2 - diam) / 2)\r\n                linesV.append(xs[i - 1] + d2 + diam + (d1 - diam) / 2)\r\n                linesV.append(xs[i - 1] + d3 + diam + (d2 - diam) / 2)\r\n                prev = 0\r\n            else:\r\n                linesV.append(xs[i - 1] + diam + (d1 - diam) / 2)\r\n                linesV.append(xs[i - 1] + d1 + diam + (d2 - diam) / 2)\r\n                linesV.append(xs[i - 1] + d1 + d2 + diam + (d1 - diam) / 2)\r\n                linesV.append(xs[i - 1] + d1 + d3 + diam + (d2 - diam) / 2)\r\n                prev = 1\r\n\r\n    linesV.append(max(xs) + diam * 1.5)\r\n    if len(linesV) % 2 == 0:\r\n        linesV.append(max(xs) + d2 + diam)\r\n\r\n    return linesV, d1, d2, d3, spacingX, spacingY\r\n\r\n\r\ndef get_letters(showID=False):\r\n    minYD = 0\r\n    Bxs = list(boundingBoxes)\r\n    Bxs.append((100000, 0))\r\n\r\n    dots = [[]]\r\n    for y in sorted(list(set(spacingY))):\r\n        if y > 1.3 * diam:\r\n            minYD = y * 1.5\r\n            break\r\n\r\n    # get lines of dots\r\n    for b in range(len(Bxs) - 1):\r\n        if Bxs[b][0] < Bxs[b + 1][0]:\r\n            if showID:\r\n                dots[-1].append((b, Bxs[b][0:2]))\r\n            else:\r\n                dots[-1].append(Bxs[b][0])\r\n        else:\r\n            if abs(Bxs[b + 1][1] - Bxs[b][1]) < minYD:\r\n                if showID:\r\n                    dots[-1].append((b, Bxs[b][0:2]))\r\n                else:\r\n                    dots[-1].append(Bxs[b][0])\r\n                dots.append([])\r\n            else:\r\n                if showID:\r\n                    dots[-1].append((b, Bxs[b][0:2]))\r\n                else:\r\n                    dots[-1].append(Bxs[b][0])\r\n                dots.append([])\r\n                if len(dots) % 3 == 0 and not dots[-1]:\r\n                    dots.append([])\r\n\r\n    letters = []\r\n    count = 0\r\n\r\n    for r in range(len(dots)):\r\n        if not dots[r]:\r\n            letters.append([0 for _ in range(len(linesV) - 1)])\r\n            continue\r\n\r\n        else:\r\n            letters.append([])\r\n            c = 0\r\n            i = 0\r\n            while i < len(linesV) - 1:\r\n                if c < len(dots[r]):\r\n                    if linesV[i] < dots[r][c] < linesV[i + 1]:\r\n                        letters[-1].append(1)\r\n                        c += 1\r\n                    else:\r\n                        letters[-1].append(0)\r\n                else:\r\n                    letters[-1].append(0)\r\n                i += 1\r\n\r\n    for l in range(len(letters)):\r\n        if l % 3 == 0: print()\r\n        print(letters[l])\r\n    print()\r\n\r\n    return letters\r\n\r\n\r\ndef translate(letters):\r\n    alpha = {'a': '1', 'b': '13', 'c': '12', 'd': '124', 'e': '14',\r\n             'f': '123', 'g': '1234', 'h': '134', 'i': '23', 'j': '234',\r\n             'k': '15', 'l': '135', 'm': '125', 'n': '1245', 'o': '145',\r\n             'p': '1235', 'q': '12345', 'r': '1345', 's': '235', 't': '2345',\r\n             'u': '156', 'v': '1356', 'w': '2346', 'x': '1256', 'y': '12456',\r\n             'z': '1456',\r\n             # special characters\r\n             '#': '2456', '^': '6', ',': '3', '.': '346',\r\n             '\\\"': '356', '^': '26', ':': '34', '\\'': '5'}\r\n\r\n    nums = {'a': '1', 'b': '2', 'c': '3', 'd': '4', 'e': '5', 'f': '6', 'g': '7', 'h': '8',\r\n            'i': '9', 'j': '0'}  # 2x2 braille letters\r\n\r\n    braille = {v: k for k, v in alpha.items()}\r\n    letters = np.array([np.array(l) for l in letters])\r\n    ans = ''\r\n\r\n    # printFig()              #test for gaussian blur (test2.jpg)\r\n\r\n    for r in range(0, len(letters), 3):\r\n        for c in range(0, len(letters[0]), 2):\r\n            f = letters[r:r + 3, c:c + 2].flatten()\r\n            f = ''.join([str(i + 1) for i, d in enumerate(f) if d == 1])\r\n            if f == '6': f = '26'\r\n            if not f:\r\n                if ans[-1] != ' ': ans += ' '\r\n            elif f in braille.keys():\r\n                ans += braille[f]\r\n            else:\r\n                ans += '?'\r\n        if ans[-1] != ' ': ans += ' '\r\n\r\n    def replace_nums(m):  # replace numbers\r\n        return nums.get(m.group('key'), m.group(0))\r\n\r\n    ans = re.sub('#(?P<key>[a-zA-Z])', replace_nums, ans)\r\n\r\n    def capitalize(m):  # capitalize\r\n        return m.group(0).upper()[1]\r\n\r\n    ans = re.sub('\\^(?P<key>[a-zA-Z])', capitalize, ans)\r\n\r\n    return ans\r\n\r\n\r\ndef printFig():  # shows the image processing steps\r\n    fig, axarr = plt.subplots(3, 2)\r\n    fig.suptitle('Image Processing')\r\n    axarr[0, 0].imshow(image)  # original image\r\n    axarr[0, 0].set_title(\"Original Image\")\r\n    axarr[0, 0].axis('off')\r\n\r\n    axarr[0, 1].imshow(gray)  # greyscales image\r\n    axarr[0, 1].set_title(\"Grayscale\")\r\n    axarr[0, 1].axis('off')\r\n\r\n    axarr[1, 0].imshow(edged)  # checks for areas of interest\r\n    axarr[1, 0].set_title(\"Edging\")\r\n    axarr[1, 0].axis('off')\r\n\r\n    axarr[1, 1].set_title(\"Contours\")  # shows the contours of the alignments\r\n    axarr[1, 1].imshow(image)\r\n    for x in linesV:\r\n        axarr[1, 1].axvline(x)\r\n    axarr[1, 1].axis('off')\r\n\r\n    axarr[2, 0].imshow(paper)  # counts the dots in an array\r\n    axarr[2, 0].set_title(\"Sorting Array\")\r\n    axarr[2, 0].axis('off')\r\n\r\n    axarr[2, 1].imshow(thresh)  # adds blur to remove unnecessary noise\r\n    axarr[2, 1].set_title(\"Gaussian Bluring\")\r\n    axarr[2, 1].axis('off')\r\n    plt.show()\r\n\r\n    io.imshow(thresh)  # final image\r\n    plt.title('Final Image')\r\n    plt.axis('off')\r\n    plt.show()\r\n\r\n\r\n# -----------------------MAIN------------------------- #\r\n\r\nimage, ctrs, paper, gray, edged, thresh = get_image(FILEPATH, iter=0, width=1500)  # processes image\r\n\r\ndiam = get_diameter()  # shows the area of interest for the computer\r\ndotCtrs = get_circles()\r\n\r\nquestionCtrs, boundingBoxes, xs, ys = sort_contours(dotCtrs)  # counts dot array\r\ndraw_contours(questionCtrs)  # contours image\r\n\r\nlinesV, d1, d2, d3, spacingX, spacingY = get_spacing()  # gets spacing lines\r\nletters = get_letters()  # translates braille\r\n\r\nprint(translate(letters))  # print the translated braille\r\nprintFig()           #prints the image processing steps\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/python/brailleProcessingLib.py	(revision 48db88dd91de92680b233372650d3a88afb977cf)
+++ app/src/main/python/brailleProcessingLib.py	(date 1605218857665)
@@ -20,17 +20,18 @@
     image = io.imread(FILEPATH)  # reads the url and opens the temporary image to user
 
     if width:
-        image = imutils.resize(image, width)  # resizes the image per the restricted width
+        image = imutils.resize(image, width)  # resized the image per the restricted width
     ans = image.copy()  # create a copy backup image
 
-    # image procesesing
+    # image processing
     accumEdged = np.zeros(image.shape[:2], dtype="uint8")
     gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # convert image to black and white
     blurred = cv2.GaussianBlur(gray, (5, 5), 0)  # blur to remove some of the noise
     edged = cv2.Canny(blurred, 75, 200)  # get edges(converts image to easy detectable dots)
     accumEdged = cv2.bitwise_or(accumEdged, edged)
     ctrs = imutils.grab_contours(cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL,
-                                                  cv2.CHAIN_APPROX_SIMPLE))  # get contours(increases accuracy)
+                                                  cv2.CHAIN_APPROX_SIMPLE))
+    # get contours(increases accuracy)
     docCnt = None
 
     # ensure that at least one contour was found to know an image can be processed
@@ -342,8 +343,8 @@
 
 
 # -----------------------MAIN------------------------- #
-
-image, ctrs, paper, gray, edged, thresh = get_image(FILEPATH, iter=0, width=1500)  # processes image
+# processes image
+image, ctrs, paper, gray, edged, thresh = get_image(FILEPATH, iter=0, width=1500)
 
 diam = get_diameter()  # shows the area of interest for the computer
 dotCtrs = get_circles()
@@ -355,4 +356,8 @@
 letters = get_letters()  # translates braille
 
 print(translate(letters))  # print the translated braille
-printFig()           #prints the image processing steps
+printFig()  # prints the image processing steps
+
+
+def testing():
+    return "Hello from brailleProcessingLib.py"
Index: app/src/main/python/test.py
===================================================================
--- app/src/main/python/test.py	(revision 48db88dd91de92680b233372650d3a88afb977cf)
+++ app/src/main/python/test.py	(revision 48db88dd91de92680b233372650d3a88afb977cf)
@@ -1,2 +0,0 @@
-def helloworld():
-    return "Hello World from Chaquopy!"
